---
title: "Tutorial for package `dynr`"
author: "Rob van Harrevelt"
date: "`r Sys.Date()`"
output:
  pdf_document:
    toc: true
    toc_depth: 3
    number_sections: true
linkcolor: blue    
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
  

---

# Introduction

In this tutorial I show how a simple model with rational expectations
can be solved with package `dynr`.

The example model is a version of the ISLM model with rational expectations.
This model has the following variables:

\begin{tabular}{ll|ll}
\multicolumn{2}{c|}{Endogenous variables} & \multicolumn{2}{c}{Exogenous variables} \\
\hline
$Y$      & national income            & $G$      & government spending   \\
$Y^D$    & dispensible income         & $Ms$     & money supply          \\
$T$      & tax                        &          &                       \\
$C$      & consumption                &          &                       \\
$I$      & investments                &          &                       \\
$M^D$    & money demand               &          &                       \\
\end{tabular}

The model equations are given by
\begin{eqnarray*}
Y_t   &=& C_t + I_t + G_t        \label{eqn:islm1:y}\\
Y^D_t &=& Y_t - T_t            \label{eqn:islm1:yd}\\                   
T_t   &=& t_0 + t_1 Y_t  \label{eqn:islm1:t}\\
C_t  &=& c_0 + c_1 Y^D_{t-1} + c_2 Y^D_t + c_3 Y^D_{t-1]} + c_4 r_t + c_5 r_t\label{eqn:islm1:c}\\
I_t   &=& i_0 + i_1  Y_{t-1} + i_2 Y_t + i_3 Y_{t+1} + i_4 r_t + i_5 r_t^2\label{eqn:islm1:i}\\
M^d_t &=& m_0 + m_1 Y_t + m_2 r_t + m_3 r_t^2 + m_3 r_t^2\label{eqn:islm1:md}\\
M^d_t &=& M^s_t                                         \label{eqn:islm1:mequ}
\end{eqnarray*}

<!--   
PREPARATIONS
-->
```{r echo = FALSE, message = FALSE}

library(dynr)

# input/output chunks are separated
# R inputlines start with >, outputlines with nothing
knitr::opts_chunk$set(collapse = FALSE, comment = "", prompt = TRUE)
```

## The mod file

`dynr` uses the same mod file as Dynare. However, only the `var`, `varexo`,
`parameters`, `model` and `initval` blocks are used. The other blocks in the
mod file are ignored.

The mod file for the ISLM has the following contents:
```{r echo = FALSE, comment=''}
cat(readLines('islm.mod'), sep = '\n')
```

## The `DynMod` class

The function `compile_model` creates a `DynMod` object from 
the mod file.

```{r}
mdl <- compile_model("islm.mod")
mdl
```

A `DynMod` object is an R6 class object. R6 
classes behave quite differently than the more familiar S3 and S4 classes. 
For example, for R6 classes methods are part of the object itself and not of 
generic functions. R6 classes behave simular to classes in
object oriented languages such as Java, C++ or Python. 

For example, the method `get_params()` can be used to
obtain the parameters of the model
```{r}
mdl$get_params()
```

Methods starting with `get_`, are ofter called a "getter" methods.
There are also corresponding "setter" methods. For example
```{r}
mdl$set_params(c(m0 = 100))
mdl$get_params("m0")
```
Input for function `set_params()` is a named numerical vector.

## Cloning `DynMod` object

Consider the following assignment:
```{r}
mdl2 <- mdl
```
Now variables `mdl2` and `mdl` refer to the same object. If you modify
`mdl2`, then also `mdl` is modified.
```{r}
mdl2$set_params(c(m0 = 75))
mdl$get_params("m0")
```
The usual copy-on-modify semantics that it used for convential
R objects such as S3 or S4 classes does not apply to R6 classes.

If you want to create a copy of the model, use the `clone()` method.
```{r}
mdl2 <- mdl$clone()
mdl2$set_params(c(m0 = -9999))
mdl$get_params("m0")
```

## Computing the steady state

To compute the steady state of the model, use
```{r}
mdl$solve_steady(control = list(trace = 1))
```

This method uses the package `nleqslv` to solve for the steady state.
Argument `control` is specified to get an iteration report.

The method `get_static_endos()` returns the computed static endogenous variables.
```{r}
mdl$get_static_endos()
```

The steady state computation requires

*  Static values for the exogenous variables
*  An initial guess for the static values of the endogenous variables

After compiling a model, these values are set to the corresponding
values in the `initval` block of the mod file (or set to 0).
You can change these values with `set_steady_exos()` or `set_steady_endos()`.
Input for these function is a named numerical vector.
For example:
```{r, eval = FALSE}
mdl$set_static_exos(c(g = 240))
```

## The model period
```{r}
mdl$set_period(regperiod_range("2015", "2020"))
```

```{r}
mdl$get_endo_data()
```

## Solving the model

Suppose that we know the values of the endogenous variables
$Y$ and $Y^D$  in the lag period 2014. 
We can set these model values as follows
```{r}
y  <- regts(1200, start = "2014")
yd <- regts(1000, start = "2014")
mdl$set_endo_data(cbind(y, yd))
```

Further suppose that in 2015 we know the intended government spending:
```{r}
g <- regts(280, start = "2015")
mdl$set_exo_data(g, names = "g")
```

Note that in this example argument `names` has to be specified, because univariate
timeseries do not have column names. Now we can solve the model using the stacked time Newton method;
```{r}
mdl$solve(control = list(trace = TRUE))
```

```{r, fig.show='hold'}
plot(mdl$get_endo_data(names = 'y'))
```

The methods `set_endo_value()` and `set_exo_value` are usefull for simple experiments,
but in a more typical applications the exogenous shocks and values of the
endogenous variables are stored in a csv file. For example,
consider the following csv file
```{r echo = FALSE, comment=''}
cat(readLines('input.csv'), sep = '\n')
```

To update the model workspace, first read the csv file and convert it to a
`regts`
```{r}
df <- read.csv("input.csv")
ts <- as.regts(df, time_column = 1)
ts
```
Then update the model data with
```{r}
mdl$set_data(ts, update_mode = "updval")
```

The `update_mode` `"updval"` is used here: this update mode
makes sure that the NA values in the timeseries data are ignored.

If the exogenous and endogenous data are in different files,
then you can use the methods `set_endo_data()` or
`set_exo_data()` instead of `set_data()`.
